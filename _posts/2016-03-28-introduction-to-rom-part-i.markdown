---
title:  "Introduction to ROM: Part I"
date:   2016-03-28 17:00:00 -0400
categories: jekyll update
color: blue
layout: post
---
Ruby Object Mapper (ROM) is a data access framework with an approach and philosophy very different from that of ActiveRecord and other Object Relation Mappers (a similarity in naming which is, admittedly, a bit unfortunate.) While ROM emphasizes separation of concerns and composition, ActiveRecord focuses mostly on ease-of-use and sheer number of features—both of which have great appeal to developers. The flip side is that the learning curve for ROM can be daunting, while AR/ORMs can induce insane amounts of coupling in your app and severely restrict developer freedom down the road.

How does ActiveRecord lead to coupling? Let me count the ways. The simplest is the globally accessible query interface—being able to call `where` on any model from anywhere—which can lead to app code littered with knowledge of the database schema. Before you cry "best practices:" named scopes aren't much of an improvement, seeing as they are still globally accessible and often only barely veil the specifics of the database schema. Other bullshit "best practices" like "thin controller, thick model" lead to monster model classes full of business logic—pretty much the definition of tightly coupled code. Less obviously, the one-table-one-model approach couples your business domain and your database schema, which is sometimes fine but often not. Not-quite-finally, by combining querying, data representation, validation, lifecycle, and persistence your app is limited to a single database and persistance strategy, oftentimes encompassing an enormous amount of business logic.

Note that "coupled" means difficult to change—not strictly impossible. Being able to swap out libraries with similar APIs (or SQL databases) does not mean it isn't tightly coupled. In fact, being heavily dependent on a third party's interface is another good definition of coupling (see the Dependency Inversion Principle.) This is where—in other less abstract discussions of coupling—someone sneers and declares that they're never going to want a different UX for their app, or a different database, or a different email provider, so why does the coupling matter? Well, for one: you don't know that, and two: bad design is bad design—our inability to predict the future is one reason we practice good code design practices, but it isn't the only one. Testability, extensibility, and maintainability are all immediate concerns that are improved along with code design.

There are strategies to mitigate some of the damage that ActiveRecord can cause. At best, they reduce but do not eliminate the problem. Regardless of efficacy, they are almost never put into practice. The attitude seems to be—if not outright hostility to any alternative—at least a resigned acceptance that one has made his or her deal with the devil. Rather than try to cut the baby in twain, ROM starts over from first principles. It's an unfortunate truth that ROM is initially so unfamiliar to many devs not because it is bizarre or nonsensical, but because the well-accepted, well-founded, and time-tested principles it embodies have been so thoroughly eschewed by Rails and ActiveRecord.

## The Database is Not Your App

The fundamental principle at play here is that of the architectural boundary—the place where your app and another system or concern interact with one another. Architectural boundaries aren't necessarily large, but the larger ones are pretty obvious and important: database, file system, network connectivity, in-memory store, etc. They're *boundaries* because from the perspective of your app what lies on the other side is not important—the file system could be real or a mock and your app does exactly the same things. The database could be SQL, NoSQL, or flat files and your app has to use the data in the same exact ways and eventually output the same exact updated data. Conversely, the less agnostic your business code is toward whatever is on the other side of a boundary, the more tightly coupled it is and the weaker the boundary.

If you're having trouble accepting that your app shouldn't care about what database you have on the other side of the boundary, consider this: Imagine a world where SQL is an obscure, relatively new and untested technology and NoSQL is the default, go-to data storage solution. Does that change *anything* about what your app actually needs to do, from a business perspective? Does a single user story change? Does a single formula for calculating some vital piece of data change? No, of course not. On the other hand, how wide is the impact on the code? How many classes have to change, even a little? The best case scenario is only your model classes have to be reworked—but even that alone can be an arduous prospect implicating thousands of lines of business logic.

The idea, again, isn't that you should care about these things because you might someday replace Postgres with Mongo. The point is your code *shouldn't* care about whether its data comes from Postgres or Mongo because it ultimately *makes no difference*, from a business logic perspective. By making your code care, you are, objectively, making it less valuable in the long-term and increasing maintenance costs, while simultaneously reducing its testability and confidence in any tests. You're handicapping your code, tying it to irrelevant detail for little to no upside.

The code forming the boundary mediates between two very different worlds—the world of your domain objects and business rules on one side, and an almost unfathomably complex piece of software doing something very specific and very important on the other. Architectural boundaries are not reducible to a single class wrapping up obscure details of a protocol inside a nice API. Instead, they translate and mediate between your app and the external system, speaking the language of your domain on one side and the language of the external system on the other.

Coupling happens when details cross over the architectural boundary and mold our code in unavoidable ways. This is exactly what happens with ActiveRecord, because ActiveRecord doesn't actually concern itself with translating between our app and the database—instead it operates from the assumption that your database and your app are the same thing. Rather than translate your business concepts to the database and back again, it simply provides high-level hooks into the low-level boundary not to bridge the boundary, but to erase it.

Even worse, huge chunks of the app domain are in actuality simply imported across the boundary, with models being in 1-to-1 correspondence with database tables and with attributes patterned directly off of table schema. As if that weren't bad enough, by having so completely obliterated the boundary developers are universally encouraged to view the database as an extension of their Rails app, with schema changes and migrations directly correlated with changes to the app. The idea that your database is completely isomorphic to and a part of your app is sheer folly, but it is almost Rails gospel.

## Mo' Responsibilities, Mo' Problems

One of the driving factors behind the emergence of NodeJS and Javascript on the server is the canard of shared code. Thousands of devs have been conned into working with an excruciatingly bad language on a platform with a plethora of fantastic alternatives, at least partly through the fantasy of common classes on the server and in the browser. While surely there has been some of that—although I suspect it's mostly just platform-agnostic libraries that get shared and not so much business code—the reality of the situation at the app developer level is often a horror show of non-reusable code, with the same giant, thousand-line god classes encompassing dozens of responsibilities that you'll find in many Rails apps. What is going wrong such that a community obsessed with DRY and a community obsessed with code portability both end up with these single-use monstrosities, and what does it say about how much we actually value code reusability?

A lot of the blame goes to the libraries that are popular and the patterns they push. Encouraging—or enforcing—inheritance over composition leads to large classes with numerous responsibilities, just as a matter of course. Community pressure or "best practices" combined with laziness can then lead to an explosion of responsibilities, as plugins and developers add more and more code to a handful of classes. Finally, having an artificially limited range of "kinds" of classes a developer believes he or she can have (Model, Controller) leads directly to a parsimony of classes, and indeed a general trend of developer resistance towards adding new classes (maybe because it makes the "models" folder look so messy.)

DRY, an almost religious mantra in Rails circles, boils down to increasing code reusability through refactoring. Unfortunately, that's fundamentally at odds with the broader development pattern that is encouraged by almost everything else about Rails. The massive classes apps and libraries often end up with prevent code reuse through tight coupling from two directions.

From the top-down, a god class makes so many assumptions about how it is being used and what it is working with that it can only be used in a handful of ways, if that. If a graphics class internalizes the generation of output files, it'll probably be difficult to extend it to support other formats. If your models handle their own persistence, it can be nigh-impossible to persist the same model in different ways depending on context. If your model is also where you put data filtering and formatting accessors, then having to provide different views of the same data can lead to an combinatoric explosion of methods. Decisions that were made universally based on initial convenience almost never pan out in the long-term for most use-cases, leading to awkward compromises and workarounds which ever-more-tightly couple the class to its circumstances.

From the bottom-up, the classes lock up code that might otherwise be generalizable and applicable elsewhere. Code to handle the peculiarities of graphics file formats could find other uses, were it not buried in a god class's private methods. Code to run reports on data can be refactored and made more powerful and flexible if it were its own class. One example of something that is successfully and commonly extracted from the AR hierarchy is serialization (via, e.g., ActiveModel::Serializers), exactly the sort of concern that should be treated as a separate responsibility.

Bottom line: there's an inverse relationship between composability and number of responsibilities. The more responsibilities you pile into a class, the less composable it is, and the less use you'll get out of your code, on average (which means you'll write more code, in the long run.)

## Rails Models Have Many "Reasons to Change"

The Single Responsibility Principle says (spoilers) that every class should have a single responsibility—which is sometimes defined as "a reason to change." The "reason to change" clarification is useful because too often "responsibility" is conflated with a Rails "resource"—this class is responsible for posts, that's a single responsibility, right? Well, no. No, it isn't. Not at all.

Let's take a look at the responsibilities a `Post` class has in a Rails app. It loads the schema from its database, so that it knows what attributes it has. It defines the relationships between your models. It provides for querying the database. It performs domain validations on records. It *is* the data itself, and handles accessing and mutating record data. It persists (create or update as needed) records to its database. And all of that's without any user code.

Add in things like Paperclip and Devise and the responsibilities explode, before the dev even begins to pile on business responsibilities. What if you want to change how a post is persisted, without changing anything else? Good luck. Want different validations depending on whether the logged in user is an admin? I hope you like duplicated code and hackish workarounds. Persist auto-save drafts to an in-memory store rather than the database? Abandon all hope, ye who enter.

The thing is, when you first start a project or when you start with simple projects and gradually work your way up in terms of complexity, this can look pretty good—of course you don't want to worry about where a particular model is getting stored, or managing sets of validations. Of course! It "just works" ... for now. Eventually, though, all the things that AR makes so easy and simple at first glance will be your "reasons to change"—maybe not today, and maybe not tomorrow, but soon. Then what?

*Part 2, which will actually be about ROM, is coming later this week*